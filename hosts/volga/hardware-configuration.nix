# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{ config, lib, pkgs, modulesPath, ... }:

{
  imports =
    [
      (modulesPath + "/installer/scan/not-detected.nix")
    ];

  boot = {
    initrd.availableKernelModules = [ "amdgpu" "vfio-pci" "nvme" "xhci_pci" "ahci" "usb_storage" "usbhid" "sd_mod" ];

    # TODO: make this configurable, required for IOMMU
    #   initrd.preDeviceCommands = ''
    # DEVS="0000:12:00.0 0000:12:00.1"
    # for DEV in $DEVS; do
    #   echo "vfio-pci" > /sys/bus/pci/devices/$DEV/driver_override
    # done
    # modprobe -i vfio-pci
    #   '';

    initrd.kernelModules = [ ];
    extraModulePackages = [ ];
    # extraModprobeConfig ="options vfio-pci ids=1002:73ff,1002:ab28";
    kernelModules = [ "vfio" "vfio_iommu_type1" "vfio_pci" "kvm-amd" ];
    kernelParams = [
      # HACK Disables fixes for spectre, meltdown, L1TF and a number of CPU
      #      vulnerabilities. Don't copy this blindly! And especially not for
      #      mission critical or server/headless builds exposed to the world.
      "mitigations=off"
      "amdgpu.noretry=0"
      "amd_iommu=on"
    ];

    # Refuse ICMP echo requests on my desktop/laptop; nobody has any business
    # pinging them, unlike my servers.
    kernel.sysctl."net.ipv4.icmp_echo_ignore_broadcasts" = 1;
  };

  # Displays
  services.xserver = {
    serverFlagsSection = ''
      Option "StandbyTime" "0"
      Option "SuspendTime" "0"
      Option "OffTime" "0"
      Option "BlankTime" "0"
    '';
  };

  # NixOS hardware options
  hardware = {
    xone.enable = true; # Xbox controller support
    onlykey.enable = true; # Enable OnlyKey device
  };

  # Custom hardware options
  modules.hardware = {
    audio.enable = true;
    wacom.enable = true;
    bluetooth.enable = true;
    radeon.enable = true;
    microcontroller.enable = true;
    qmk.enable = true;
    android.enable = true;
    fs = {
      enable = true;
      ssd.enable = false; # I use instead discard=async with BTRFS
    };
    sensors.enable = true;

    # hardware utilities to benchmark, stress test, get hardware info, etc.
    utilites.enable = true;
  };

  fileSystems."/" =
    {
      device = "/dev/disk/by-uuid/be3fc6b1-d2d0-4c37-ab40-53567d54e67d";
      fsType = "btrfs";
      options = [ "subvol=root" "compress=zstd" ];
    };

  fileSystems."/boot" =
    {
      device = "/dev/disk/by-uuid/EF8C-D8DA";
      fsType = "vfat";
    };

  fileSystems."/home" =
    {
      device = "/dev/disk/by-uuid/be3fc6b1-d2d0-4c37-ab40-53567d54e67d";
      fsType = "btrfs";
      options = [ "subvol=home" "compress=zstd" ];
      neededForBoot = true; # required to load ssh key with agenix early
    };

  fileSystems."/nix" =
    {
      device = "/dev/disk/by-uuid/be3fc6b1-d2d0-4c37-ab40-53567d54e67d";
      fsType = "btrfs";
      options = [ "subvol=nix" "compress=zstd" ];
    };

  fileSystems."/games" =
    {
      device = "/dev/disk/by-uuid/be3fc6b1-d2d0-4c37-ab40-53567d54e67d";
      fsType = "btrfs";
      options = [ "subvol=games" "compress=zstd" ];
    };

  fileSystems."/archive" =
    {
      device = "/dev/disk/by-uuid/ff1ddb67-6528-49b3-8159-3d26eb97d431";
      fsType = "btrfs";
      options = [
        "subvol=root"
        "compress=zstd"
        "nofail" # Prevent system from failing if this drive doesn't mount
      ];
    };

  swapDevices = [ ];

  # Enable btrfs auto scrubbing
  # checking file consistency
  services.btrfs.autoScrub.enable = true;

  # CPU
  nix.settings.max-jobs = lib.mkDefault 12;
  powerManagement.cpuFreqGovernor = "performance";
  hardware.cpu.amd.updateMicrocode = true;

  # UPS
  # generate password file, just use passwordFile is not enough in some reason
  # TODO: need replace secrets file with agenix
  system.activationScripts."upsmon-secret" = ''
    SECRET="${config.age.secrets.upsmon.path}"
    CONFIG_FILE="${config.user.home}/.secrets/upsmon"
    ${pkgs.coreutils-full}/bin/cat "$SECRET" > "$CONFIG_FILE"
  '';
  power.ups = {
    enable = true;
    ups."apcBX950U" = {
        driver = "usbhid-ups";
        port = "auto";
        description = "APC Back-UPS BX950U";
    };

    users.upsmon = {
      passwordFile = "${config.user.home}/.secrets/upsmon";
      upsmon = "master";
    };

    upsmon.monitor."apcBX950U".user = "upsmon";
  };

  # Enables DHCP on each ethernet and wireless interface. In case of scripted networking
  # (the default) this is the recommended approach. When using systemd-networkd it's
  # still possible to use this option, but it's recommended to use it in conjunction
  # with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.
  networking.useDHCP = lib.mkDefault true;
  # networking.interfaces.enp34s0.useDHCP = lib.mkDefault true;

  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
}