{ config, options, pkgs, lib, ... }:

with lib;
with lib.my;
let cfg = config.modules.shell.bash;
    configDir = config.dotfiles.configDir;
in {
  options.modules.shell.bash = with types; {
    enable = mkBoolOpt false;
    defaultShell = mkBoolOpt false;

    # aliases = mkOpt (attrsOf (either str path)) {};
    #
    # rcInit = mkOpt' lines "" ''
    #   bash lines to be written to $XDG_CONFIG_HOME/zsh/extra.zshrc and sourced by
    #   $XDG_CONFIG_HOME/bash/.zshrc
    # '';
    # envInit = mkOpt' lines "" ''
    #   bash lines to be written to $XDG_CONFIG_HOME/zsh/extra.zshenv and sourced
    #   by $XDG_CONFIG_HOME/bash/.zshenv
    # '';
    #
    # rcFiles  = mkOpt (listOf (either str path)) [];
    # envFiles = mkOpt (listOf (either str path)) [];
  };

  config = mkIf cfg.enable {
    programs.bash = {
      # I init completion myself, because enableGlobalCompInit initializes it
      # too soon, which means commands initialized later in my config won't get
      # completion, and running compinit twice is slow.
      # enableCompletion = true;
      # enableGlobalCompInit = false;
      # # Again. I configure the prompt myself, so disable the default.
      # promptInit = "";
      interactiveShellInit = ''
        # ================================
        # Utilites
        # ================================

        # usage: checkBin <binary name/path>
        function checkBin() {
          local _binary="$1" _full_path

          # Checks if the binary is available.
          _full_path=$( command -v "$_binary" )
          commandStatus=$?
          if [ $commandStatus -ne 0 ]; then
            echo "Unable to find binary '$_binary'."
          else
            # Checks if the binary has "execute" permission.
            [ -x "$_full_path" ] && return 0

            echo "Binary '$_binary' found but it does not have *execute* permission."
          fi

          # Otherwise, simple returns an error code.
          return 107
        }


        # ================================
        # Configuration
        # ================================

        # fzf
        if checkBin fzf-share; then
          export FZF_DEFAULT_OPTS="--reverse --ansi"
          export FZF_DEFAULT_COMMAND="fd ."

          export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
          export FZF_ALT_C_COMMAND="fd -t d . $HOME"
          export FZF_CTRL_R_COMMAND=
          source "$(fzf-share)/key-bindings.bash"
        fi

        checkBin starship && eval "$(starship init bash)"
        checkBin zoxide && eval "$(zoxide init bash)"
        checkBin leetcode && eval "$(leetcode completions bash)"

        # atuin
        checkBin atuin && eval "$(atuin init bash)"

        if [ "$SSH_CLIENT" ]; then
           # I have logged in via SSH, check pinentry-auto in gnupg.nix
           export PINENTRY_USER_DATA=USE_CURSES
        fi
      '';
    };

    # Some shell utilies I find indispensible.
    user.packages = with pkgs; [
      atuin
      nix-bash-completions
      bat
      bat-extras.batman
      eza
      fzf
      starship
      zoxide
    ];

    env = {
    };

    # home.configFile = {
    #   "starship.toml".source = "${configDir}/starship/starship.toml";
    #
    #   "atuin/config.toml".text = ''
    #     style = "compact"
    #     update_check = false
    #     show_help = false
    #     inline_height = 20
    #   '';
    #
    #   # Write it recursively so other modules can write files to it
    #   "bash" = { source = "${configDir}/zsh"; recursive = true; };
    #
    #   # Why extra.bash{rc,env} when I could be using extraInit? Because extraInit
    #   # generates those files in /etc/profile, and mine just write the files to
    #   # ~/.config/bash; where it's easier to edit and tweak them in case of
    #   # issues or when experimenting. Plus, my bash dotfiles should be relatively
    #   # NixOS agnostic, so they can still be deployed elsewhere.
    #   "bash/extra.zshrc".text =
    #     let aliasLines = mapAttrsToList (n: v: "alias ${n}=\"${v}\"") cfg.aliases;
    #     in ''
    #        # Clean up DM leftovers, as much as we can. This can only be for
    #        # non-essential cleanup, as setupCommands only works on some DMs
    #        # (e.g. LightDM, GDM, and SDDM).
    #        rm -rf ~/.pki ~/.nv
    #
    #        # This file was autogenerated, do not edit it!
    #        ${concatStringsSep "\n" aliasLines}
    #        ${concatMapStrings (path: "source '${path}'\n") cfg.rcFiles}
    #        ${cfg.rcInit}
    #
    #        if (( $+commands[starship] )); then
    #          eval "$(starship init bash)"
    #        fi
    #
    #        if (( $+commands[zoxide] )); then
    #          eval "$(zoxide init bash)"
    #        fi
    #
    #        if (( $+commands[leetcode] )); then
    #          eval "$(leetcode completions bash)"
    #        fi
    #
    #        if [ "$SSH_CLIENT" ]; then
    #            # I have logged in via SSH, check pinentry-auto in gnupg.nix
    #            export PINENTRY_USER_DATA=USE_CURSES
    #        fi
    #     '';
    #
    #   "bash/extra.zshenv".text = ''
    #     # This file is autogenerated, do not edit it!
    #     ${concatMapStrings (path: "source '${path}'\n") cfg.envFiles}
    #     ${cfg.envInit}
    #   '';
    # };

    # system.userActivationScripts.cleanupZgen = ''
    #   rm -rfv $bash_CACHE $ZGEN_DIR/init.zsh{,.zwc}
    # '';
  };
}